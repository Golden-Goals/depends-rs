use std::collections::{BTreeMap, BTreeSet, HashSet};

use crate::core::{Identifiable, Visitor};

#[derive(Debug)]
struct Node {
    id: usize,
    name: &'static str,
}

/// A [Visitor] which builds a `Graphviz` representation of a given graph.
///
/// ```
/// # use std::{collections::HashSet, rc::Rc};
/// #
/// # use depends::{
/// #     core::{
/// #         Depends, Dependency, HashValue, LeafNodeRc, Resolve, UpdateDependeeMut, UpdateLeafMut,
/// #         NodeHash
/// #     },
/// #     derives::{Dependee, Dependencies, Leaf},
/// # };
/// #
/// # // A `Leaf` is a node which takes new values from outside the graph.
/// # #[derive(Leaf, Default)]
/// # pub struct NumberInput {
/// #     value: i32,
/// # }
/// #
/// # impl HashValue for NumberInput {
/// #     fn hash_value(&self) -> NodeHash {
/// #         NodeHash::Hashed(self.value as usize)
/// #     }
/// # }
/// #
/// # // `Leaf` types must provide a way for code outside to update their internal state.
/// # // This is just a simple replace for now.
/// # impl UpdateLeafMut for NumberInput {
/// #     type Input = i32;
/// #
/// #     fn update_mut(&mut self, input: Self::Input) {
/// #         self.value = input;
/// #     }
/// # }
/// #
/// # // `Dependencies` are derived to state what references `Dependee` nodes need to
/// # // calculate their state on-demand. These could be any number of other `Dependee`s
/// # // or `Leaf`s.
/// # #[derive(Dependencies)]
/// # pub struct Components {
/// #     left: Dependency<LeafNodeRc<NumberInput>>,
/// #     right: Dependency<LeafNodeRc<NumberInput>>,
/// # }
/// #
/// # // A `Dependee` i.e. its state is a pure transformation of other nodes
/// # #[derive(Dependee, Default)]
/// # #[depends(dependencies = Components)]
/// # pub struct Sum {
/// #     value: i32,
/// # }
/// #
/// # impl HashValue for Sum {
/// #     fn hash_value(&self) -> NodeHash {
/// #         NodeHash::Hashed(self.value as usize)
/// #     }
/// # }
/// #
/// # // This trait specifies how a `Dependee` updates its internal state given its dependencies.
/// # impl UpdateDependeeMut for Sum {
/// #     fn update_mut(&mut self, input: <Self as Depends>::Input<'_>) {
/// #         // `ComponentsRef` is auto-generated by `Dependencies`. It's a read-reference
/// #         // to each field of `Components`
/// #         let ComponentsRef { left, right } = input;
/// #         self.value = left.data().data().value + right.data().data().value;
/// #     }
/// # }
/// #
/// # struct MyGraph {
/// #     left: LeafNodeRc<NumberInput>,
/// #     right: LeafNodeRc<NumberInput>,
/// #     // `SumNode` is auto-generated by `Dependee`.
/// #     sum: Rc<SumNode>,
/// # }
/// #
/// use depends::graphviz::GraphvizVisitor;
///
/// // Compose a graph.
/// let left = NumberInput::default().into_leaf();
/// let right = NumberInput::default().into_leaf();
/// let sum = Sum::default().into_node(Components::new(Dependency::new(Rc::clone(&left)), Dependency::new(Rc::clone(&right))));
///
/// let graph = MyGraph { left, right, sum };
///
/// let mut visitor = GraphvizVisitor::new();
///
/// // resolve the graph with this visitor
/// graph.sum.resolve(&mut visitor);
///
/// // A Graphviz representation is now available on the visitor!
/// assert_eq!(visitor.render().unwrap(), r#"
/// digraph G {
///   2[label="Sum"];
///   0[label="NumberInput"];
///   1[label="NumberInput"];
///   0 -> 2;
///   1 -> 2;
/// }
/// "#.trim());
/// ```
#[derive(Debug, Default)]
pub struct GraphvizVisitor {
    visitor: HashSet<usize>,
    nodes: Vec<Node>,
    edges: BTreeMap<usize, BTreeSet<usize>>,
}

impl GraphvizVisitor {
    pub fn new() -> Self {
        Self::default()
    }

    /// Render the visited graph to Graphviz DOT format. Returns [Option::None]
    /// if no graph has been visited.
    pub fn render(&self) -> Option<String> {
        if self.nodes.is_empty() {
            None
        } else {
            let mut lines = Vec::new();
            lines.push(String::from("digraph G {"));
            self.nodes
                .iter()
                .for_each(|n| lines.push(format!("  {}[label=\"{}\"];", n.id, n.name)));
            self.edges.iter().for_each(|(p, children)| {
                children.iter().for_each(|c| {
                    lines.push(format!("  {} -> {};", c, p));
                })
            });
            lines.push(String::from("}"));
            Some(lines.join("\n"))
        }
    }
}

impl Visitor for GraphvizVisitor {
    fn visit<N>(&mut self, node: &N) -> bool
    where
        N: Identifiable,
    {
        let result = self.visitor.visit(node);
        if result {
            self.nodes.push(Node {
                id: node.id(),
                name: N::name(),
            });
        }
        result
    }

    fn mark_edge<N>(&mut self, node: &N)
    where
        N: Identifiable,
    {
        // Relies on the implementation of the resolver. This isn't great.
        let parent_id = self
            .nodes
            .last()
            .expect("`mark_edge` called before initial `resolve`")
            .id;
        self.edges.entry(parent_id).or_default().insert(node.id());
    }

    fn clear(&mut self) {
        self.visitor.clear();
        self.nodes.clear();
        self.edges.clear();
    }
}
