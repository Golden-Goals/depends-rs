//! # Depends
//!
//! A library for ergonomic, performant, incremental computation between
//! arbitrary types.
//!
//! For more information, see:
//! - [Getting Started Guide](https://justice4joffrey.github.io/depends-rs)
//! - [Examples](https://github.com/Justice4Joffrey/depends-rs/tree/master/examples)
//! - [Benchmarks](https://github.com/Justice4Joffrey/depends-rs/tree/master/benches)
//!
//! ## Motivation
//!
//! Many applications which respond to changes from multiple input sources
//! benefit from the use of dependency graphs as code structure. By breaking
//! complex states down in to small pieces of testable, composable logic,
//! scaling and maintaining applications becomes much easier over time.
//! Additionally, incremental computation allows results of previous
//! calculations to be reused where possible, improving overall efficiency
//! and performance.
//!
//! Depends aims to present the smallest possible API surface for building
//! minimal runtime-overhead dependency graphs in Rust, whilst leveraging
//! the compile-time guarantees of the type-system.
//!
//! ```
//! # use std::cell::{RefMut};
//! # use std::{
//! #     hash::{Hash, Hasher},
//! # };
//! # use std::collections::HashSet;
//! # use std::rc::Rc;
//! #
//! # use depends::error::{EarlyExit, ResolveResult};
//! # use depends::{NodeState, SingleRef, TargetMut};
//! # use depends::{
//! #     DerivedNode, InputNode, Resolve, UpdateDerived, UpdateInput,
//! #     derives::{Dependencies, Operation, Value},
//! # };
//! /// A unit of data within a graph.
//! #[derive(Value, Default, Hash)]
//! pub struct NumberValue {
//!     pub value: i32,
//! }
//!
//! impl NumberValue {
//!     pub fn new(value: i32) -> Self {
//!         Self { value }
//!     }
//! }
//!
//! // By implementing UpdateInput, we can change the value of this node from
//! // outside of the graph.
//! impl UpdateInput for NumberValue {
//!     type Update = i32;
//!
//!     fn update_mut(&mut self, update: Self::Update) {
//!         // Implementing this trait will provide a way for code outside of this graph to
//!         // change its internal state. This is just a simple replace for now.
//!         self.value = update;
//!     }
//! }
//!
//! /// Any [DerivedNode] must state its dependencies. If there are more than one,
//! /// this must be wrapped in a struct which derived [Dependencies] as shown.
//! /// Otherwise, it can be passed to a [DerivedNode] wrapped with the
//! /// [Dependency] type.
//! #[derive(Dependencies)]
//! pub struct TwoNumbers {
//!     left: NumberValue,
//!     right: NumberValue,
//! }
//!
//! /// We must define the transformations for each derived node.
//! /// Given a set of inputs and a target value, describe how to update the
//! /// state. In this example, it's just a simple multiplication.
//! #[derive(Operation)]
//! struct Multiply;
//!
//! // Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
//! // represents read-references to all of its fields.
//! impl UpdateDerived for Multiply {
//!     type Input<'a> = TwoNumbersRef<'a> where Self: 'a;
//!     type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;
//!
//!     fn update_derived(
//!         TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
//!         mut target: TargetMut<'_, NumberValue>,
//!     ) -> Result<(), EarlyExit> {
//!         target.value = left.value * right.value;
//!         Ok(())
//!     }
//! }
//!
//! // Compose a graph!
//! // Below are input nodes, which are nodes which take new values from
//! // outside the graph.
//! let a = InputNode::new(NumberValue::new(7));
//! let b = InputNode::new(NumberValue::new(6));
//!
//! // Derived nodes take their value from other nodes (either input or
//! // derived). Note that we can combine _any_ type of node, not just
//! // [NumberValue]s.
//! let c = DerivedNode::new(
//!     TwoNumbers::init(Rc::clone(&a), Rc::clone(&b)),
//!     Multiply,
//!     NumberValue::default(),
//! );
//!
//! // A visitor tracks which nodes have been visited during a resolve.
//! let mut visitor = HashSet::<usize>::new();
//!
//! // Resolve the graph!
//! // `resolve_root` will clear the visitor before returning, readying it
//! // for the next resolution.
//! // This can fail if there are cycles in the graph or an existing read
//! // reference is being held.
//! # {
//! let res = c.resolve_root(&mut visitor).unwrap();
//! assert_eq!(res.value, 42);
//! # }
//!
//! // Nodes which have an edge to dependencies which are updated between
//! // resolves will recalculate their state on-demand. Others will return
//! // a cached value. This is known as incremental computation, and can
//! // vastly improve performance of complex calculations.
//! a.update(70).unwrap();
//!
//! // Any dependent values will be updated next time the graph is resolved.
//! # {
//! let res = c.resolve_root(&mut visitor).unwrap();
//! assert_eq!(res.value, 420);
//! # }
//! ```
#![cfg_attr(doc_cfg, feature(doc_cfg, doc_auto_cfg))]

mod execution;
pub use execution::*;

pub mod derives {
    //! Derive macros for `depends`.
    pub use depends_derives::*;
}

/// Visualisation tool for graphs.
#[cfg(feature = "graphviz")]
pub mod graphviz;
