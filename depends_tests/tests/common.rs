#![allow(dead_code)]

use std::hash::{Hash, Hasher};

use depends::{
    core::{error::EarlyExit, SingleRef, TargetMut, UpdateDerived, UpdateInput},
    derives::{Dependencies, Operation, Value},
};

/// A unit of data within a graph.
#[derive(Value, Default, Hash)]
pub struct NumberValue {
    pub value: i32,
}

impl NumberValue {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for NumberValue {
    type Update = i32;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Any [DerivedNode] must state its dependencies. If there are more than one,
/// this must be wrapped in a struct which derived [Dependencies] as shown.
/// Otherwise, it can be passed to a [DerivedNode] wrapped with the
/// `Dependency` type.
#[derive(Dependencies)]
pub struct TwoNumbers {
    left: NumberValue,
    right: NumberValue,
}

/// We must define the transformation functions for each derived node.
/// Given a set of inputs and a target value, describe how to update the
/// state. In this example, it's just a simple addition.
#[derive(Operation)]
pub struct Add;

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
impl UpdateDerived for Add {
    type Input<'a> = TwoNumbersRef<'a> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = left.value + right.value;
        Ok(())
    }
}

#[derive(Operation)]
pub struct Square;

impl UpdateDerived for Square {
    // Note: we can combine different types in the same graph.
    type Input<'a> = SingleRef<'a, NumberValue> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        input: SingleRef<'_, NumberValue>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = input.value.pow(2);
        Ok(())
    }
}

#[derive(Operation)]
pub struct Multiply;

impl UpdateDerived for Multiply {
    type Input<'a> = TwoNumbersRef<'a> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = left.value * right.value;
        Ok(())
    }
}
