#![allow(dead_code)]

use std::{
    cell::RefMut,
    hash::{Hash, Hasher},
};

use depends::{
    core::{error::ResolveResult, NodeState, SingleRef, TargetMut, UpdateInput},
    derives::{Dependencies, Value},
};

/// A unit of data within a graph.
#[derive(Value, Default, Hash)]
pub struct NumberValue {
    pub value: i32,
}

impl NumberValue {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for NumberValue {
    type Update = i32;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Any [DerivedNode] must state its dependencies. If there are more than one,
/// this must be wrapped in a struct which derived [Dependencies] as shown.
/// Otherwise, it can be passed to a [DerivedNode] wrapped with the
/// `Dependency` type.
#[derive(Dependencies)]
pub struct TwoNumbers {
    left: NumberValue,
    right: NumberValue,
}

/// We must define the transformation functions for each derived node.
/// Given a set of inputs and a target value, describe how to update the
/// state. In this example, it's just a simple addition.
///
/// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
/// represents read-references to all of its fields.
pub fn add(
    TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
    mut target: TargetMut<'_, NumberValue>,
) -> ResolveResult<()> {
    target.value = left.value + right.value;
    Ok(())
}

/// The square transformation depends on a single input.
pub fn square(
    input: SingleRef<'_, NumberValue>,
    mut target: TargetMut<'_, NumberValue>,
) -> ResolveResult<()> {
    target.value = input.value.pow(2);
    Ok(())
}

pub fn multiply(
    TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
    mut target: RefMut<'_, NodeState<NumberValue>>,
) -> ResolveResult<()> {
    target.value = left.value * right.value;
    Ok(())
}
