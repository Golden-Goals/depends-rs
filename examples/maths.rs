#![allow(dead_code)]

use std::{
    collections::HashSet,
    hash::{Hash, Hasher},
    rc::Rc,
};

use depends::{
    core::{
        error::EarlyExit, Dependency, DerivedNode, InputNode, Resolve, SingleRef, TargetMut,
        UpdateDerived, UpdateInput,
    },
    derives::{Dependencies, Operation, Value},
    graphviz::GraphvizVisitor,
};

/// A unit of data within a graph.
#[derive(Value, Default, Hash)]
pub struct NumberValue {
    pub value: i32,
}

impl NumberValue {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for NumberValue {
    type Update = i32;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Another unit of data within a graph, just to demonstrate we can combine
/// arbitrary types, so long as we know how to translate the output of one to
/// the input of another.
#[derive(Value, Default, Hash)]
pub struct OtherNumberValue {
    pub value: i8,
}

impl OtherNumberValue {
    pub fn new(value: i8) -> Self {
        Self { value }
    }
}

impl UpdateInput for OtherNumberValue {
    type Update = i8;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Any [DerivedNode] must state its dependencies. If there are more than one,
/// this must be wrapped in a struct which derived [Dependencies] as shown.
/// Otherwise, it can be passed to a [DerivedNode] wrapped with the
/// `Dependency` type.
#[derive(Dependencies)]
pub struct TwoNumbers {
    left: NumberValue,
    right: NumberValue,
}

#[derive(Dependencies)]
pub struct ThreeNumbers {
    a: NumberValue,
    b: NumberValue,
    c: NumberValue,
}

/// We must define the transformation functions for each derived node.
/// Given a set of inputs and a target value, describe how to update the
/// state. In this example, it's just a simple addition.
#[derive(Operation)]
struct Add;

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
impl UpdateDerived for Add {
    type Input<'a> = TwoNumbersRef<'a> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = left.value + right.value;
        Ok(())
    }
}

#[derive(Operation)]
struct AddThree;

impl UpdateDerived for AddThree {
    type Input<'a> = ThreeNumbersRef<'a> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        ThreeNumbersRef { a, b, c }: ThreeNumbersRef<'_>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = a.value + b.value + c.value;
        Ok(())
    }
}

#[derive(Operation)]
struct Square;

impl UpdateDerived for Square {
    // Note: we can combine different types in the same graph.
    type Input<'a> = SingleRef<'a, OtherNumberValue> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        input: SingleRef<'_, OtherNumberValue>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = input.value.pow(2) as i32;
        Ok(())
    }
}

#[derive(Operation)]
struct Multiply;

impl UpdateDerived for Multiply {
    type Input<'a> = TwoNumbersRef<'a> where Self: 'a;
    type Target<'a> = TargetMut<'a, NumberValue> where Self: 'a;

    fn update_derived(
        TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
        mut target: TargetMut<'_, NumberValue>,
    ) -> Result<(), EarlyExit> {
        target.value = left.value * right.value;
        Ok(())
    }
}

fn main() {
    // Create some input nodes. These are nodes we can update from outside of
    // the graph.
    let a = InputNode::new(NumberValue::new(1));
    let b = InputNode::new(NumberValue::new(2));
    // Note that we can combine different types in the same graph.
    let c = InputNode::new(OtherNumberValue::new(3));
    let d = InputNode::new(NumberValue::new(4));
    let e = InputNode::new(NumberValue::new(5));

    // Now for some derived nodes. We can't update these from outside of the
    // graph. They are updated when their dependencies change.

    // C squared
    let g = DerivedNode::new(
        Dependency::new(Rc::clone(&c)),
        Square,
        NumberValue::default(),
    );
    // Sum of a and b
    let h = DerivedNode::new(
        TwoNumbers::init(Rc::clone(&a), Rc::clone(&b)),
        Add,
        NumberValue::default(),
    );
    // Product of d and e
    let i = DerivedNode::new(
        TwoNumbers::init(Rc::clone(&d), Rc::clone(&e)),
        Multiply,
        NumberValue::default(),
    );
    // Create another edge to node a
    let j = DerivedNode::new(
        TwoNumbers::init(Rc::clone(&a), Rc::clone(&i)),
        Add,
        NumberValue::default(),
    );

    // Finally, the sum of all of the above
    let answer = DerivedNode::new(
        ThreeNumbers::init(Rc::clone(&g), Rc::clone(&h), Rc::clone(&j)),
        AddThree,
        NumberValue::default(),
    );

    // We can render the graph to Graphviz format
    let mut visitor = GraphvizVisitor::new();
    answer.resolve(&mut visitor).unwrap();
    println!("{}", visitor.render().unwrap());

    // We can now resolve the graph. This will update all of the derived
    // nodes
    let mut visitor = HashSet::<usize>::new();
    {
        // This can fail if there are cycles in the graph or an existing read
        // reference is being held.
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 1: {}", res.value);
        assert_eq!(res.value, (3_i32.pow(2)) + (1 + 2) + (1 + (4 * 5)));
    }
    {
        // If we update input nodes, any nodes which depend on them will be
        // re-resolved. Those which don't will return their cached value.
        a.update(10).unwrap();
        b.update(12).unwrap();
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 2: {}", res.value);
        assert_eq!(res.value, (3_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    }
    {
        // The graph contains multiple types whose edges are type-checked.
        // Therefore, only valid graphs can be constructed.
        c.update(5).unwrap();
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 3: {}", res.value);
        assert_eq!(res.value, (5_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    }
}
